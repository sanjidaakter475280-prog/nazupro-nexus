Implementation Plan: Real-time Socket.io & MongoDB Integration
We are moving away from the serverless Data API to a Custom Express Backend hosted on Render. This allows for Socket.io real-time signaling with near-zero latency.

User Review Required
IMPORTANT

Since you are using Render (Free Tier), the server will "sleep" after 15 minutes of inactivity. The first request after a sleep period might take 30-60 seconds to wake up.

Required Env Vars (on Render & Local):
MONGODB_URI: Your MongoDB Atlas connection string (The server uses this to connect to the DB).
PORT: 5000 (standard).
CORS_ORIGIN: Your frontend URL.
NOTE

The MongoDB Atlas database stays in the cloud. The Docker container on Render will connect to it using the MONGODB_URI securely. All bot data and signals will be stored there.

Proposed Changes
1. Persistent Backend Setup
File: 
server/index.ts
Initialize Express, Mongoose, and Socket.io.
Create routes for bot management and historical logging.
Implement Socket.io namespaces for real-time signal broadcasting.
2. Python Bot Bridge
File: cloud_sync.py (or integrated into 
back2.py
)
Use python-socketio client to emit signals directly to the Render server.
Synchronize configuration changes received via WebSockets from the dashboard.
3. Cleanup
File: 
server/package.json
 (Update as needed)
Ensure all dependencies for Express and Socket.io are present.
Phase 3: Website-Based Bot Control
This phase transitions the Python bot control from Telegram to the dashboard.

3. Remove Telegram & Flask Integration
File: 
back2.py
Delete 
TelegramBot
 imports and initialization.
Delete Flask Health Check: Remove the app_flask initialization and 
run_flask
 threading logic. This is no longer needed as the bot will act as a Socket.io client.
Replace 
safe_send_message_to_telegram
 with database-backed logging and notification logic.
2. Implement cloud_sync.py (Python)
NEW File: cloud_sync.py in the Python project.
Polling/Socket loop to read bots collection and sync global_vars (asset, amount, expiration, mode).
Reports live signals and execution results back to MongoDB signals collection.
Phase 4: Multi-Bot Signal Feed & Tactical Flow
1. Dual-Action Signaling (Python & Server)
Python Bot: Emit new_signal events from 
back2.py
 via Socket.io to the Render server.
Render Server: Upon receiving a signal, it will perform two actions concurrently:
Persistence: Save the signal to the MongoDB Atlas signals collection for history.
Real-time Broadcast: Instantly push the signal to all connected React Frontend clients via Socket.io.
2. Tactical View & Navigation (Frontend)
File: 
App.tsx
Implement socket.io-client in 
apiService.ts
 or a new socketService.ts.
When "START BOT" is clicked, emit a start_bot command and switch currentView to 'signals'.
File: 
SignalTacticalView.tsx
Subscribe to real-time signal events and update the 
SignalFeed
 instantly.
Phase 5: Centralized Asset Management
This phase moves pair filtering from the Python bot to the website to reduce bot-side processing.

1. Simplify Bot Data Fetching with "Safe Filter"
File: 
back2.py
 / 
global_value.py
Remove complex 
filter_and_load_pairs()
 logic.
Raw Payout Event:
The bot fetches ALL available pairs from the Pocket Option API.
It applies a Safe Filter (Payout >= 70%) internally.
It emits the raw_payouts event via Socket.io, containing only the high-payout pairs.
This ensures the website receives a clean list of tradeable assets without overloading the connection with low-payout junk.
2. Global Asset Hub (Frontend)
File: 
AssetsView.tsx
 & 
BotCommandCenter.tsx
Replace static AVAILABLE_ASSETS with live data fetched from the Socket.io server.
Move filtering logic (Min Payout, Market Type: OTC/Forex/Crypto) into the React useMemo hooks.
Asset selection will update the bots collection in MongoDB, which the Python bot will sync via cloud_sync.py.
3. Identified Files for Python Update
back2.py
: Remove 
filter_and_load_pairs
, 
update_filtered_pairs
, and legacy Telegram payout messages.
global_value.py
:
Keep global_vars for internal bot state.
Modify 
update_payout_data
 to emit raw_payouts to Socket.io instead of just saving to 
config.json
.
Modify 
update_setting
 to broadcast changes to the Render server if they originate from the bot, and listen for updates from the server.
cloud_sync.py:
Bridge global_vars with the MongoDB bots collection.
Handle incoming update_config events from Socket.io to update 
global_value.py
 state in real-time.
Phase 6: Dockerization for Deployment
This phase ensures a professional and consistent deployment on Render.

1. Container Strategy
File: c:\Users\NAZMUL\Desktop\Pocket options\nazupro-nexus (v3)\Dockerfile
Multi-stage Build Steps:
Frontend Build Stage: Use node:20 image, install frontend deps, and run npm run build to generate the dist folder.
Backend & Runtime Stage: Use node:20-slim, copy the server folder, install backend deps (express, socket.io, mongoose), and copy the dist folder from the first stage.
Serving: Configure the Express server to serve 
index.html
 for all non-API routes.
Port: Expose PORT 5000 (or whatever Render assigns).
Environment: Use .dockerignore to keep the image slim.
2. Deployment Scripting
Update root 
package.json
 to include a render-build script that executes both frontend and backend builds if needed.
Phase 7: Telegram Extraction & Remote Command Re-engineering (A to Z)
This phase completely detaches the bot from Telegram and establishes the new Web-to-Bot command channel.

1. The Purge (Removing Telegram)
Delete Files: [DELETE] telegrambot.py (No longer needed).
Update 
back2.py
:
Remove from telegrambot import TelegramBot (Line 53).
Remove self.telegram_bot initialization in 
initialize_telegram_bot
 (Purge the entire method).
Remove the try/except block in __main__ that starts the Telegram polling (Lines 5309-5328).
Replace all self.telegram_bot.send_message() calls with a new self.broadcast_event(event_type, data) which emits via Socket.io.
2. Command Re-engineering (The New Web-to-Bot Bridge)
Problem: Previously, Telegram used a synchronous 
api_callback_wrapper
 to talk to the bot's logic.
Solution: The new cloud_sync.py will act as a real-time event listener.
Website Action: User clicks "Set Amount: 10$" on the dashboard.
Flow: Website -> Render Server (Socket.io) -> Python Bot (cloud_sync.py).
Logic in cloud_sync.py:
@sio.on('bot_command')
async def on_command(data):
    # data = {"command": "set_amount", "value": 10}
    await bot.handle_remote_command(data['command'], data['value'])
Refactor 
api_callback
: Rename 
api_callback
 in 
back2.py
 to handle_remote_command and ensure it's fully 
async
 (it already handles asyncio.create_task, so we will streamline it).
3. Data Consistency & Normalization (The "Amount" Rule)
Problem: React uses tradeAmount and 
expiry
, while Python uses 
amount
 and expiration.
Solution: Standardize all variable names to match the Python bot's schema for zero-overhead JSON syncing.
Changes in React (
types.ts
 & 
App.tsx
):
Rename tradeAmount -> 
amount
Rename 
expiry
 -> expiration
Rename tradingMode -> 
trading_mode
Rename assignedAssetSymbol -> selected_pair
Constant Variable Usage:
Create a constants.ts (React) and constants.py (Python) to define these keys.
Example: BOT_KEYS = { AMOUNT: 'amount', EXPIRATION: 'expiration' }.
4. Verification of Command Flow
Test 1: Change "Amount" on the website and verify global_vars['amount'] updates in the bot's console.
Test 2: Trigger "Scan Pairs" from the website and verify the bot starts 
fetch_and_process_payouts()
.
Verification Plan
Automated Tests
python test_mongodb_sync.py: Verify signals are written correctly to Atlas.
Dashboard Flow Test: Start a bot and confirm the UI automatically redirects to the Tactical Signal View.
Manual Verification
Start/Stop bot from the website and confirm the Python bot reacts and signals appear in the feed.
Verify that signals are correctly filtered by the active bot in the Tactical View.
Check that 
AssetsView
 correctly displays all pairs fetched from the API and filters them based on user input.